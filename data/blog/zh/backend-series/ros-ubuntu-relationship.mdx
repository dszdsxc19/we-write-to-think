---
title: 'ROS ä¸ Ubuntu çš„å…³ç³»ç¬”è®°'
date: 2023-12-17T00:03:59+08:00
draft: false
tags: ['ROS', 'æœºå™¨äººå¼€å‘']
summary: 'å˜æ¸… ROSã€Ubuntuã€é©±åŠ¨ä¹‹é—´çš„å…³ç³»ï¼Œå¹¶è®°å½•è‡ªå®šä¹‰æ¶ˆæ¯å®è·µã€‚'
---

## å®˜ç½‘

> The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it's all open source.

## ç»´åŸºç™¾ç§‘

[æœºå™¨äººæ“ä½œç³»ç»Ÿï¼ˆç»´åŸºç™¾ç§‘ï¼‰](https://en.wikipedia.org/wiki/Robot_Operating_System)

> Robot Operating System (ROS or ros) is an open-source robotics middleware suite. Although ROS is not an operating system (OS) but a set of software frameworks for robot software development, it provides services designed for a heterogeneous computer cluster such as hardware abstraction, low-level device control, implementation of commonly used functionality, message-passing between processes, and package management. Running sets of ROS-based processes are represented in a graph architecture where processing takes place in nodes that may receive, post, and multiplex sensor data, control, state, planning, actuator, and other messages. Despite the importance of reactivity and low latency in robot control, ROS is not a real-time operating system (RTOS). However, it is possible to integrate ROS with real-time code.The lack of support for real-time systems has been addressed in the creation of ROS 2, a major revision of the ROS API which will take advantage of modern libraries and technologies for core ROS functions and add support for real-time code and embedded system hardware.

## åšå®¢

> Ubuntuæ˜¯ä¸€ä¸ªä»¥æ¡Œé¢åº”ç”¨ä¸ºä¸»çš„Linuxæ“ä½œç³»ç»Ÿï¼Œè€Œraspbianæ˜¯é’ˆå¯¹ Raspberry Pi ä¸“é—¨ä¼˜åŒ–ã€åŸºäº Debian çš„ Raspbian OSã€‚
>
> ROSè¯´æ˜¯å«æœºå™¨äººæ“ä½œç³»ç»Ÿï¼Œå…¶å®å¹¶ä¸æ˜¯åƒUbuntué‚£æ ·å®Œæ•´çš„ç³»ç»Ÿï¼Œå¯ä»¥ç†è§£æˆROSä¸€ä¸ªä¸­é—´ä»¶æˆ–è€…ä¸€ä¸ªåº“ï¼Œå®ƒéœ€è¦è·‘åœ¨Ubuntuç³»ç»Ÿä¸Šï¼Œæˆ–è€…raspbianç³»ç»Ÿä¸Šã€‚
>
> æ ‘è“æ´¾æ˜¯ç¡¬ä»¶ï¼Œæ˜¯æ“ä½œç³»ç»Ÿ Ubuntuæˆ–è€…raspbiançš„è½½ä½“ï¼Œå®‰è£…äº†ROSçš„Ubuntuç³»ç»Ÿæ‰èƒ½ä½¿ç”¨ROSä¸­çš„å·¥å…·ï¼Œæ¡†æ¶ç­‰ã€‚

# è‡ªå®šä¹‰æ¶ˆæ¯

```
catkin_create_pkg custom_message roscpp std_msgs geometry_msgs message_generation

```

ä¸ä¹‹å‰ä¸åŒçš„æ˜¯ï¼Œéœ€è¦åœ¨packages.xmlä¸­æ·»åŠ å¦‚ä¸‹å‰ä¸¤è¡Œä¿¡æ¯ï¼ˆæ³¨æ„ï¼Œä¸æ˜¯ç¬¬ä¸‰è¡Œï¼Œé‚£ç§å†™æ³•å·²ç»æ¶ˆå¤±ï¼‰ã€‚

```
<build_depend>message_generation</build_depend>
<exec_depend>message_generation</exec_depend>
<!-- <exec_depend>message_runtime</exec_depend> -->

```

CMakeLists.txtå¦‚ä¸‹ï¼š

```
cmake_minimum_required(VERSION 3.0.2)
project(custom_message)

find_package(catkin REQUIRED COMPONENTS
  geometry_msgs
  message_generation
  roscpp
  std_msgs
)

# æ–°å¢
add_message_files(
  FILES
  Person.msg
)

# æ–°å¢
generate_messages(
  DEPENDENCIES
  std_msgs
)

# æ–°å¢
catkin_package(
  CATKIN_DEPENDS geometry_msgs message_generation roscpp std_msgs
)

include_directories(
  ${catkin_INCLUDE_DIRS}
)

add_executable(talker1 src/talker1.cpp)
target_link_libraries(talker1 ${catkin_LIBRARIES})

add_executable(listener1 src/listener1.cpp)
target_link_libraries(listener1 ${catkin_LIBRARIES})

```

talkerä»£ç ï¼ˆæ³¨æ„è‡ªå®šä¹‰æ¶ˆæ¯å¤´æ–‡ä»¶çš„å¼•å…¥æ–¹æ³•æ˜¯ï¼šåŠŸèƒ½åŒ…å + æ¶ˆæ¯åï¼Œä½¿ç”¨æ—¶éƒ½éœ€è¦æŒ‡å‡ºå‘½åç©ºé—´ä¸ºåŠŸèƒ½åŒ…çš„åç§°ï¼‰ï¼š

```
#include <sstream>
#include "ros/ros.h"
#include "custom_message/Person.h"
int main(int argc, char **argv)
{
    // ROSèŠ‚ç‚¹åˆå§‹åŒ–
    ros::init(argc, argv, "talker1");
    // åˆ›å»ºèŠ‚ç‚¹å¥æŸ„
    ros::NodeHandle n("hello");
    // åˆ›å»ºä¸€ä¸ªPublisherï¼Œå‘å¸ƒåä¸ºchatterçš„topicï¼Œæ¶ˆæ¯ç±»å‹ä¸ºcustom_messages::Person
    ros::Publisher chatter_pub = n.advertise<custom_message::Person>("custom_msg", 1000);
    // è®¾ç½®å¾ªç¯çš„é¢‘ç‡
    ros::Rate loop_rate(10);
    int count = 0;
    while (ros::ok())
    {
        // åˆå§‹åŒ–std_msgs::Stringç±»å‹çš„æ¶ˆæ¯
        custom_message::Person msg;
        msg.name = "Lucas Tan";
        msg.sex = custom_message::Person::unknown;
        // å‘å¸ƒæ¶ˆæ¯
        ROS_INFO("%s", msg.name.c_str());
        chatter_pub.publish(msg);
        // å¾ªç¯ç­‰å¾…å›è°ƒå‡½æ•°
        ros::spinOnce();
        // æŒ‰ç…§å¾ªç¯é¢‘ç‡å»¶æ—¶
        loop_rate.sleep();
        ++count;
    }
    return 0;
}

```

listenerä»£ç ï¼š

```
#include "ros/ros.h"
#include "custom_message/Person.h"
// æ¥æ”¶åˆ°è®¢é˜…çš„æ¶ˆæ¯åï¼Œä¼šè¿›å…¥æ¶ˆæ¯å›è°ƒå‡½æ•°
void chatterCallback(const custom_message::Person::ConstPtr& msg)
{
    // å°†æ¥æ”¶åˆ°çš„æ¶ˆæ¯æ‰“å°å‡ºæ¥
    ROS_INFO("I heard: [%s]", msg->name.c_str());
}
int main(int argc, char **argv)
{
    // åˆå§‹åŒ–ROSèŠ‚ç‚¹
    ros::init(argc, argv, "listener1");
    // åˆ›å»ºèŠ‚ç‚¹å¥æŸ„
    ros::NodeHandle n("hello");
    // åˆ›å»ºä¸€ä¸ªSubscriberï¼Œè®¢é˜…åä¸ºchatterçš„è¯é¢˜ï¼Œæ³¨å†Œå›è°ƒå‡½æ•°chatterCallback
    ros::Subscriber sub = n.subscribe("custom_msg", 1000, chatterCallback);
    // å¾ªç¯ç­‰å¾…å›è°ƒå‡½æ•°
    ros::spin();
    return 0;
}

```

æœ€ç»ˆæ•ˆæœï¼š
ï¼ˆæ­¤å¤„åŸä¸ºç¤ºæ„å›¾ç‰‡ï¼Œå·²ç§»é™¤ï¼‰

# std_msgs

é€šè¿‡rosmsgå‘½ä»¤å¯ä»¥æ–¹ä¾¿åœ°æŸ¥çœ‹æœ‰å“ªäº›msgåŠŸèƒ½åŒ…ä»¥åŠmsgçš„ç»“æ„ã€‚

```
root@f90027cc500f:~# rosmsg -h
rosmsg is a command-line tool for displaying information about ROS Message types.

Commands:
	rosmsg show	Show message description
	rosmsg info	Alias for rosmsg show
	rosmsg list	List all messages
	rosmsg md5	Display message md5sum
	rosmsg package	List messages in a package
	rosmsg packages	List packages that contain messages

Type rosmsg <command> -h for more detailed usage

```

æ¯”å¦‚æŸ¥çœ‹ Image æ¶ˆæ¯çš„ç»“æ„ï¼ˆæ— éœ€åˆ°å¤„ç¿»åŒ…çš„ç›®å½•ï¼Œæˆ‘æ˜¯ğŸ¤¡ï¼‰
ï¼ˆæ­¤å¤„åŸä¸ºç»“æ„æˆªå›¾ï¼Œå·²ç§»é™¤ï¼‰

# ros::spin() å’Œ ros::spinOnce()åŒºåˆ«

é¦–å…ˆæ˜ç¡®ï¼Œè¿™ä¸¤ä¸ªéƒ½æ˜¯**ROSæ¶ˆæ¯å›è°ƒå¤„ç†å‡½æ•°ã€‚**ä¹Ÿå°±æ˜¯è¯´æ˜¯ç”¨äºè®¢é˜…è€…çš„ã€‚

## åŒºåˆ«

ros::**spin()**åœ¨è°ƒç”¨åä¸ä¼šå†è¿”å›ï¼Œä¹Ÿå°±æ˜¯ä½ çš„ä¸»ç¨‹åºåˆ°è¿™å„¿å°±ä¸å¾€ä¸‹æ‰§è¡Œäº†ï¼Œè€Œæ˜¯è¿›è¡Œä¸‹ä¸€æ¬¡å›è°ƒã€‚ï¼ˆros::spin()å‡½æ•°ä¸€èˆ¬ä¸ä¼šå‡ºç°åœ¨å¾ªç¯ä¸­ï¼Œå› ä¸ºç¨‹åºæ‰§è¡Œåˆ°spin()åå°±ä¸è°ƒç”¨å…¶ä»–è¯­å¥äº†ï¼Œä¹Ÿå°±æ˜¯è¯´è¯¥å¾ªç¯æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼‰ã€‚

è€ŒÂ **ros::spinOnce()**åè€…åœ¨è°ƒç”¨åè¿˜å¯ä»¥ç»§ç»­æ‰§è¡Œä¹‹åçš„ç¨‹åºï¼Œä½†å¾€å¾€éœ€è¦è€ƒè™‘è°ƒç”¨æ¶ˆæ¯çš„æ—¶æœºï¼Œè°ƒç”¨é¢‘ç‡ï¼Œä»¥åŠæ¶ˆæ¯æ± çš„å¤§å°ã€‚

é€šå¸¸å’Œå¾ªç¯ä»¥åŠloop_rate.sleep()ä¸€èµ·ä½¿ç”¨ã€‚

## ä»£ç å¯¹æ¯”åŒºåˆ«

### talker

```
#include "ros/ros.h"
#include "std_msgs/String.h"
// Why we need sstream? Because we need this to split a sentence to words.
#include <sstream>

int main(int argc, char **argv)
{
    // init, can not have namespace
    ros::init(argc, argv, "talker");
    // start, this is a c11 initialization mode
    ros::NodeHandle n("namespace");
    // Define publisher's topic name and msg type.
    ros::Publisher chatter_pub = n.advertise<std_msgs::String>("chatter", 1000);
    // set loop rate(per sec)
    ros::Rate loop_rate(10);
    int count = 0;
    // ros::ok()åœ¨ä»¥ä¸‹å‡ ç§æƒ…å†µä¸‹ä¼šè¿”å›false, æŒ‰ä¸‹Ctrl-Cæ—¶ã€‚æˆ‘ä»¬è¢«ä¸€ä¸ªåŒååŒå§“çš„èŠ‚ç‚¹ä»ç½‘ç»œä¸­è¸¢å‡ºã€‚ros::shutdown()è¢«åº”ç”¨ç¨‹åºçš„å¦ä¸€éƒ¨åˆ†è°ƒç”¨ã€‚æ‰€æœ‰çš„ros::NodeHandleséƒ½è¢«é”€æ¯äº†ã€‚
    while (ros::ok())
    {
        std_msgs::String msg;
        std::stringstream ss;
        ss << "hello world " << count;
        msg.data = ss.str();
        ROS_INFO("%s", msg.data.c_str());
        /**
         * å‘ Topic: chatter å‘é€æ¶ˆæ¯, å‘é€é¢‘ç‡ä¸º10Hzï¼ˆ1ç§’å‘10æ¬¡ï¼‰ï¼›æ¶ˆæ¯æ± æœ€å¤§å®¹é‡1000ã€‚
         */
        chatter_pub.publish(msg);
        // å¦‚æœè¿è¡Œåˆ°ä¸‹ä¸€æ¬¡loop.sleep()åæœªè¾¾åˆ°è®¾ç½®çš„æ—¶é—´ï¼Œåˆ™ä¼šå¼€å§‹ä¼‘çœ ï¼Œç­‰åˆ°åå†æ‰§è¡Œä¸‹ä¸€å¥
        loop_rate.sleep();
        ++count;
    }
    return 0;
}

```

### listenerï¼šspin()

```
#include "ros/ros.h"
#include "std_msgs/String.h"

// subscriber callback function
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
    ROS_INFO("I heard: [%s]", msg->data.c_str());
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "listener");
    ros::NodeHandle n("namespace");
    ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);

    /**
     * ros::spin() å°†ä¼šè¿›å…¥å¾ªç¯ï¼Œ ä¸€ç›´è°ƒç”¨å›è°ƒå‡½æ•°chatterCallback(),æ¯æ¬¡è°ƒç”¨1000ä¸ªæ•°æ®ã€‚
     * å½“ç”¨æˆ·è¾“å…¥Ctrl+Cæˆ–è€…ROSä¸»è¿›ç¨‹å…³é—­æ—¶é€€å‡ºï¼Œ
     */
    ros::spin();
    return 0;
}

```

### listenerï¼šspinOnce()

```
#include "ros/ros.h"
#include "std_msgs/String.h"

// subscriber callback function
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
    ROS_INFO("I heard: [%s]", msg->data.c_str());
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "listener");
    ros::NodeHandle n("namespace");
    ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);

    ros::Rate loop_rate(5);
    while(ros::ok()){
        ros::spinOnce();
        loop_rate.sleep();
    }
    return 0;
}

```

# ROS ä¸ OpenCV

## ä» ROS åˆ° OpenCV

è¦ç†è§£ï¼Œæ ¸å¿ƒæ˜¯åœ¨opencvã€‚rosåªæ˜¯ä¸€ä¸ªè¾“å…¥çš„å·¥å…·ã€‚

```
#include <ros/ros.h>
// Using image_transport for publishing and subscribing to images in ROS allows you to subscribe to compressed image streams.
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
// some useful constants and functions related to image encodings.
#include <sensor_msgs/image_encodings.h>
// OpenCV's image processing and GUI modules.
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

static const std::string OPENCV_WINDOW = "Image window";

class ImageConverter
{
    ros::NodeHandle nh_;
    // image_transportç±»ï¼šå›¾åƒä¼ è¾“ç±»ï¼Œå…¶åŠŸèƒ½å’ŒROSä¸­çš„Publisherå’ŒSubscriberå·®ä¸å¤šï¼Œä½†æ˜¯ä¸åŒçš„æ˜¯è¿™ä¸ªç±»åœ¨å‘å¸ƒå’Œè®¢é˜…å›¾ç‰‡æ¶ˆæ¯çš„åŒæ—¶è¿˜é™„å¸¦è¿™æ‘„åƒå¤´çš„ä¿¡æ¯ã€‚
    // ç›¸æ¯”è¾ƒä¹‹ä¸‹, åœ¨ROSä¸­ä¼ é€å›¾ç‰‡ä¿¡æ¯ï¼Œä½¿ç”¨image_transportç±»è¦é«˜æ•ˆçš„å¤šã€‚
    image_transport::ImageTransport it_;
    image_transport::Subscriber image_sub_;
    image_transport::Publisher image_pub_;

public:
    ImageConverter()
        : it_(nh_)
    {
        // Subscrive to input video feed and publish output video feed
        image_sub_ = it_.subscribe("/camera/image_raw", 1,
                                   &ImageConverter::imageCb, this);
        image_pub_ = it_.advertise("/image_converter/output_video", 1);

        // OpenCV HighGUI calls to create/destroy a display window on start-up/shutdown.
        cv::namedWindow(OPENCV_WINDOW);
    }

    ~ImageConverter()
    {
        cv::destroyWindow(OPENCV_WINDOW);
    }

    void imageCb(const sensor_msgs::ImageConstPtr &msg)
    {
        // CvBridge defines a CvImage type containing an OpenCV image, its encoding and a ROS header.
        // ä¸­æ–‡è¯´çš„è¯å°±æ˜¯ï¼š cv_bidge::CvImageç±»ï¼šcv_bridgeä¸­æä¾›çš„æ•°æ®ç»“æ„ï¼Œé‡Œé¢åŒ…æ‹¬OpenCVä¸­çš„cv::Matç±»å‹çš„å›¾åƒä¿¡æ¯ï¼Œå›¾åƒç¼–ç æ–¹å¼ï¼ŒROSå¤´æ–‡ä»¶ç­‰ç­‰ã€‚
        cv_bridge::CvImagePtr cv_ptr;
        try
        {
            // Note that OpenCV expects color images to use BGR channel order.
            cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
        }
        catch (cv_bridge::Exception &e)
        {
            ROS_ERROR("cv_bridge exception: %s", e.what());
            return;
        }

        // Draw an example circle on the video stream
        if (cv_ptr->image.rows > 60 && cv_ptr->image.cols > 60)
            cv::circle(cv_ptr->image, cv::Point(50, 50), 10, CV_RGB(255, 0, 0));

        // Update GUI Window
        cv::imshow(OPENCV_WINDOW, cv_ptr->image);
        cv::waitKey(3);

        // Output modified video stream
        image_pub_.publish(cv_ptr->toImageMsg());
    }
};

int main(int argc, char **argv)
{
    ros::init(argc, argv, "image_converter");
    ImageConverter ic;
    ros::spin();
    return 0;
}

```

å¯¹åº”çš„CMakeListsï¼š

```
cmake_minimum_required(VERSION 3.0.2)
project(opencv_study)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  sensor_msgs
  cv_bridge
  std_msgs
  image_transport
)

catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES opencv_study
#  CATKIN_DEPENDS roscpp rospy
#  DEPENDS system_lib
)

include_directories(
# include
  ${catkin_INCLUDE_DIRS}
)

add_executable(image_converter src/image_converter.cpp)
target_link_libraries(image_converter ${catkin_LIBRARIES})

```

## **è¯é¢˜åç§°é‡æ˜ å°„**

```
rosrun opencv_study image_converter /camera/image_raw:=/camera/color/image_raw

```

è¿™å¥è¯å°†åŸæ¥è®¢é˜…çš„è¯é¢˜`/camera/image_raw`æ”¹åä¸º`/camera/color/image_raw`ã€‚

`ros run`Â åé¢çš„å‚æ•°çš„æ„ä¹‰ï¼š

- `__ns:=`Â : æ›´æ”¹èŠ‚ç‚¹çš„å‘½åç©ºé—´
- `__name:=`:æ›´æ”¹èŠ‚ç‚¹çš„åç§°
- `A:=B`:è¯é¢˜é‡æ˜ å°„ï¼Œ`A â†’ B`

## ä» OpenCV åˆ° ROS

```
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

// OpenCV includes
#include <opencv2/video.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/calib3d/calib3d.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgcodecs/legacy/constants_c.h"

using namespace cv;

#include <ros/ros.h>
#include <cv_bridge/cv_bridge.h>
#include <image_transport/image_transport.h>
#include <sensor_msgs/image_encodings.h>

int main(int argc, char **argv)
{
	ros::init(argc, argv, "image_color");
	ros::NodeHandle nh;
	image_transport::ImageTransport it(nh);
	image_transport::Publisher pub = it.advertise("/camera_sim/image_raw", 1);
	/**************ROSä¸Opencvå›¾åƒè½¬æ¢***********************/
	Mat image = imread("/home/agilex/Desktop/ty/catkin_ws/src/scout_work_1/src/index.jpeg", CV_LOAD_IMAGE_COLOR);
	sensor_msgs::ImagePtr msg = cv_bridge::CvImage(std_msgs::Header(), "bgr8", image).toImageMsg();
	ros::Rate loop_rate(5);
	while (nh.ok())
	{
		pub.publish(msg);
		ros::spinOnce();
		loop_rate.sleep();
	}
	return 0;
}

```
