---
title: 我的 AI 编程助手探索之旅：为什么最终选择了 Claude Code
date: 2025-12-25
tags: [AI, Claude Code, 编程工具]
---

# 我的 AI 编程助手探索之旅：为什么最终选择了 Claude Code

## 前言

在过去的两年里，我几乎试遍了市面上所有的主流 AI 编程助手：Cursor、GitHub Copilot、Codex、Aider、Trae、Kiro、Roo Code、Cline、Jules、v0……在经历了漫长的探索和对比之后，我最终选择以 Claude Code 作为主力工具。

这篇文章想分享一下我的心路历程，以及我对 AI 辅助编程的一些思考。

## 工具探索之路

### 主流工具的尝试

我使用过的工具可以分为几类：

**IDE 集成类：**

- Cursor：界面友好，内置模型选择灵活，很好，阅读代码之类的非常舒服，生成代码的能力也很强，付费属性强
- GitHub Copilot：与 GitHub 生态深度集成，白嫖自动补全和免费额度还行

**命令行工具类：**

- Aider：Git 集成做得很好, 但是 Claude Code出来之后社区热度很低，可以说已经凉凉
- Roo Code、Cline：各有特色，但是使用体验始终比 Cursor 差一个档次，插件的形式我不喜欢

**在线工具类：**

- v0：适合快速原型，生成 Next.js，集成Vercel生态
- Jules（异步编程）: 很好的探索，集成很好，免费，Gemini AI Pro额度足，可以用来跑任务。但是目前来看，本地仍然是最优解，不能作为主力使用。

这些工具各有优势，但都没有完全满足我的需求。

## 为什么选择 Claude Code

### 1. MCP（Model Context Protocol）的扩展能力

Claude Code 的 MCP 系统是其最大的亮点之一。通过 MCP，我可以：

- 自定义数据源和工具集成
- 灵活扩展上下文获取能力
- 与现有工作流无缝对接

这种开放性让 Claude Code 不再是一个封闭的工具，而是一个可编程的平台。

### 2. Skills 系统

Skills 允许我定义可复用的任务模板和工作流，这大大提高了重复性操作的效率。

### 3. 不使用 RAG 的设计选择

这一点可能很多人会感到意外。Claude Code 选择不使用 RAG（检索增强生成），而是信任大模型本身的理解和推理能力。

我的使用经验印证了这个选择是正确的：

> **如果能够提供清晰的上下文，现在主流大模型的输出质量差异并不会特别大。**

关键在于如何有效地组织和管理上下文，而不是依赖外部的知识检索。

### 4. Unix 哲学的胜利

Claude Code 体现了经典的 Unix 哲学：

- **做好一件事**：专注于与模型的交互
- **可组合性**：通过管道与其他工具配合
- **文本流**：一切都以文本为中心

这种设计让它可以自然地融入现有的开发工作流。

## 我的实际使用方案

### 第一性原理：工具是为了创造价值

在深入分享我的方案之前，想先说一个更本质的问题：

**你真的需要折腾这些吗？**

从第一性原理出发，使用工具的目的是**创造价值**，而不是折腾工具本身。

Claude Code 官网可直接使用，开箱即用。对于大多数个人开发者：

- 如果官网额度够用
- 如果你对成本不敏感
- 如果你追求效率而非折腾

**那么直接用官网就好**。多模型配置的本质是"用配置复杂度换取性价比"，这个交易值不值得，取决于你的具体情况。

OpenRouter 这类产品的价值是"方便"，但对个人来说，官网获取也没什么不好。关键是想清楚自己的需求。

---

### Claude Code + 多模型策略

我没有局限于单一模型，而是根据不同任务选择合适的模型：

**复杂任务（架构设计、系统规划）：**

- 使用 Claude 4.5 Opus, GPT 5.1 Codex, Gemini 3 Pro
- 这部分通常在聊天框或终端中完成
- 重点是"先想清楚怎么做"

**日常编码（非特别复杂的问题）：**

- 使用性价比高的模型
- DeepSeek、Kimi、MiniMax 等国产模型表现优秀
- 在经济上更划算

**聊天和文本生成：**

- Google Gemini
- ChatGPT

中国的主要使用 豆包和千问，安装在手机上，想到什么随时随地问，量大管饱。

**图像相关：**

- 当然是 Nano Banana

**本地小模型**

- Ollama 部署，本地探索，跑任务

### 上下文管理是核心

我逐渐认识到，AI 编程的本质就是**上下文管理**。如果能有一个良好的上下文：

1. 清晰描述问题
2. 提供足够的代码背景
3. 明确期望的输出

那么模型的输出质量通常都不会差。

### 关于 Cursor

Cursor 是一个优秀的工具，它的补全能力确实很出色。但我最终没有继续使用，主要原因：

- 成本相对较高
- 如果大模型能够独立完成任务，额外的优化成本不值得

这让我思考一个问题：**在 AI 已经足够强大的今天，我们需要多少"优化"？**

### Spec-Driven Development 的反思

我曾经使用 GitHub 开源的 SpecKit 工具进行规范驱动开发。对于复杂任务，这确实有帮助。

但最近我越来越少使用了，原因很简单：

> **大模型的能力已经足够强，只要我能够清晰地表达需求，就不需要复杂的规范框架。**

SpecKit 太重、太复杂了。有时候，简单直接地描述需求，反而更高效。

## AI 中的知识与智慧

我越来越深刻地认识到：**AI 里面充满了人类的知识和智慧。**

关键在于如何引导：

1. **清晰的意图表达**：让 AI 理解你真正想要什么
2. **合适的上下文**：提供恰到好处的背景信息
3. **迭代式对话**：通过多轮交互完善结果

这与其说是"使用工具"，不如说是"与 AI 协作"。

## 云端与本地工具的平衡

**纯云端工具（如 v0）**：

- 适合项目初始化
- 快速搭建原型
- 无需本地配置

**本地工具（如 Claude Code）**：

- 与现有工作流深度集成
- 数据安全可控
- 可定制性强

我的方案是两者结合，根据场景选择。

## 总结

经过长时间的探索，我最终的选择是：

**Claude Code + 多模型策略 + 国产模型补充**

这个方案的核心优势：

1. **开放性**：MCP 和 Skills 让工具可以无限扩展
2. **灵活性**：根据任务选择合适的模型
3. **经济性**：简单任务用便宜模型，复杂任务用顶级模型
4. **简洁性**：不依赖复杂的框架，信任 AI 的理解能力
5. **工具与模型解耦**：这可能是最重要的优势

**关于工具与模型解耦**：

很多工具将"工具"和"模型"强绑定在一起——你选择了这个工具，就必须用它指定的模型。这带来一个问题：一旦模型付费政策变化或体验下降，你的整个工作流都会被打断。

而我选择的方式将工具和模型解耦了：

- Claude Code 是稳定的工具层
- 模型可以随时切换、自由组合

**这样的好处非常明显**：

- 某个模型不付费了？换个模型就行，使用习惯完全不变
- 想试试新模型？加一个脚本就好，无需适应新界面
- 不同任务用不同模型？一个命令就能切换

这种灵活性才是真正的"用 AI"，而不是"被 AI 用"。

最重要的是，我学会了更好地与 AI 沟通——这或许才是 AI 时代最重要的技能。

---

_如果你也在探索 AI 编程工具，希望我的经验能给你一些参考。记住：最好的工具，是适合你的工具。_
